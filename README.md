# コンセプト
このプロジェクトは、XMLデータをディレクトリ構造に展開し、Swiftで自動生成されたコードを使ってWeb APIとして提供する仕組みを示すサンプルです。
# 必要なもの
- Swift 5.3以降
- Swift Package Manager (Swiftに同梱されています)
# セットアップ手順
1. リポジトリをクローンします。
```git clone ChaosReadman/Albion.git```
2. プロジェクトディレクトリに移動します。
```cd Albion```
3. 依存関係を解決します。
```swift package resolve```
4. ビルドします。
```swift build -c release```
# XMLデータの準備
xmldataディレクトリにXMLデータを配置してください。サンプルとして、nutrient.xmlとsample.xmlが含まれています。
# クエリの準備
queryRootディレクトリにXQueryファイルを配置してください。サンプルとして、searchfoodとnutrientsのディレクトリが含まれています。

# ツール作成
mk.shを起動して、XML展開ツールを作成してください。

# XMLデータの展開
ツールを使ってXMLデータをディレクトリに展開します。

./loadxml xmldata/sample.xml mnt
./loadxml xmldata/nutrient.xml food

# ビルドキャッシュを削除
rm -rf .build

# 再度実行（依存関係の解決とビルドが最初から行われます）
swift run Run serve --port 5000

# ブラウザでアクセス
http://localhost:5000/foodinfo/searchfood?foodname=ぶどう

http://localhost:5000/foodinfo/nutrients?id=14028

http://localhost:5000/mnt/getbooks?price=0

各々のリクエスト先にあるqueryRoot/searchfood/query.xqyとqueryRoot/nutrients/query.xqyからswiftコードが自動生成され、コンパイルされ、実行され、その結果がブラウザに表示されます。

# 背景と哲学
既存のデータベースシステムが行っている「メモリ上のデータをファイルシステムへシリアライズする」という行為は、OSのファイルシステムの上に、さらにもう一つのファイルシステムを二重に構築しているように見えます。
また、同時アクセス制御なども、OSのファイルシステムに任せれば平和裏に解決される問題を、アプリケーション層で自前でロック管理を行うなど、現代の視点では余計な複雑さを抱え込んでいるように感じられます。

かつてはそのような独自実装に意味があった時代もありましたが、現代においては時代遅れになりつつあると考えます。
そこでAlbionでは、**データをそのままファイルシステムへ置き換える**ことで、誰の目にもシンプルに映る実装を最優先しました。
この思想に基づき、無駄に複雑になりがちなXQueryの完全実装を潔く諦め、ファイルシステム操作に必要な部分だけに絞って実装を行っています。

# 設計思想とXQueryサブセット
このプロジェクトは「完全なXQuery 3.0の実装」ではなく、**ファイルシステム（ディレクトリ構造）に展開されたXMLデータを効率的に操作するためのDSL（ドメイン特化言語）**として設計されています。
標準的なXQueryの構文（FLWOR式など）を借用していますが、アーキテクチャの特性上、以下の独自仕様（サブセット）となっています。

1. **データモデルの違い**
   - `doc('name')` はXMLドキュメントではなく、展開されたディレクトリを指します。
   - 変数（例: `$x`）にはXMLノードオブジェクトではなく、**ディレクトリのパス（文字列）**が格納されます。

2. **出力の挙動**
   - `return $x` と記述した場合、XML要素がシリアライズされて出力されるのではなく、そのディレクトリのパスが出力されます。
   - XMLタグとして出力したい場合は、`<tag>{$x/text()}</tag>` のように明示的にタグを構築する必要があります。

3. **パス式・関数の制約**
   - `$x/text()` はディレクトリ内の `inner.txt` を読み込みます。
   - `$x/@attr` はディレクトリ内の `attr.txt` から属性値を読み込みます。
   - `string()` や `data()` などの関数は、トランスパイラによって無視（削除）されます（既に文字列として扱われているため）。
   - 親要素へのアクセス（`..`）や子要素の属性チェックは、専用のヘルパー関数に変換される形で限定的にサポートされています。
